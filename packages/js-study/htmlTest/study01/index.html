<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h5>H5 study</h5>
    <script>
        // 下面这种自调用函数，作用是为代码分配一个独立的作用域，避免造成代码的全局污染
        // ( function a(){} )()
        // 后面 ES6 升级后，又出来一种新的更好的做法，叫做代码块，就是用 {} 花括号括起来就行了
        // 后面的代码练习我都会用 {} 代码块括起来，避免全局污染

        // (function a() {
        //     const a = 99, b = '99', c = {}, d = 9.9, e = false, f = null;
        //     let g;
        //     console.log('a => ', typeof a);
        //     console.log('b => ', typeof b);
        //     console.log('c => ', typeof c);
        //     console.log('d => ', typeof d);
        //     console.log('e => ', typeof e);
        //     console.log('f => ', typeof f);
        //     console.log('g => ', typeof g);
        // })();

    </script>

    <script>
        function suodinglianxi() {
            // 【使用 Object.freeze(XXX) 锁死变量】

            // 使用严格模式
            "use strict";
            // 如果只用 const 声明一个 JSON 变量，那么其中的属性也是允许修改了，如果想让这个 JSON 变量中的所有属性也只读，就需要用到 Object.freeze(XXX)
            const HOST = {
                url: "www.micking.top",
                port: 80
            }
            // Object.freeze(XXX) 作用：将一个变量锁死，就算这个变量是 JSON 对象类型，也会锁死，其中的所有属性将都为 只读 的，不允许修改
            Object.freeze(HOST)

            // // 这里将修改失败，因为这个 HOST 对象已经用 Object.freeze(XXX) 锁死
            // HOST.port = 99;
            // console.log("HOST => ",HOST)
        }

    </script>

    <script>
        function konglianxi() {
            // 【undefined 和 null 的区别 和 使用】
            // undefined：变量值没附上的时候，都为 undefined，没声明的变量也是 undefined；
            // null：null 需要对变量进行赋值才会出现

            // // 这个 jj 变量没有声明过，所以输出是 undefined
            // console.log(jj);
            // // 这个 kk 虽然声明了但是没有赋值，所以输出是 undefined
            // let kk;
            // console.log(kk);

            // 有时候，我们可以这么用 undefined 和 null，通常用 undefined 来声明一个空的普通变量，通常用 null 来声明一个空的 JSON 对象变量
            let ajson = null; // 这样声明方便提示自己或者别的程序员，这个 ajson 变量后面将作为 JSON 对象使用
            let bx = undefined; // 这样声明方面提示自己或告诉别的程序员，这个 bx 变量后面将作为基础数据类型的变量使用，比如 整型、字符串、浮点数等
            console.log("ajson => ", ajson);
            console.log("bx => ", bx);
            // 判断上面声明的对象变量是否为空
            if (!ajson) {
                console.log('ajson 是个空的JSON对象')
            } else {
                console.log('ajson 不是个空的JSON对象')
            }
            // 变量是否为空的判断方式
            if (!bx) {
                console.log('bx 是个空的变量')
            } else {
                console.log('bx 不是个空的变量')
            }

            // 当然上面的这种方案，在实际开发中，推荐用下面的方式，只是下面的声明方式，判断 JSON 对象是否为空的方式有所不通，需要改用 JSON.stringify(ajsonB)==="{}"
            let ajsonB = {}; // 这样声明方便提示自己或者别的程序员，这个 ajson 变量后面将作为 JSON 对象使用
            let bxB = ''; // 这样声明方面提示自己或告诉别的程序员，这个 bx 变量后面将作为基础数据类型的变量使用，比如 整型、字符串、浮点数等
            console.log("ajsonB => ", ajsonB);
            console.log("bxB => ", bxB);
            // 判断上面声明的对象变量是否为空
            if (JSON.stringify(ajsonB) === "{}") {
                console.log('ajsonB 是个空的JSON对象')
            } else {
                console.log('ajsonB 不是个空的JSON对象')
            }
            // 变量是否为空的判断方式
            if (!bxB) {
                console.log('bxB 是个空的变量')
            } else {
                console.log('bxB 不是个空的变量')
            }

            // 综上所述，我们如果对一个不知情的变量进行统一判断是否为空，那就使用如下判断
            let ax;
            if (!ax || String.stringify(ax) === '{}') {
                console.log('ax 是个空的')
            }

            // 如果我们需要判断一个变量是否为空，且如果为空，则赋上初始值，可以这样简写
            let ayy; // 如果 这里 ayy = {},或者 ayy = [] 数组 那么将不认为是空值
            let byy = ayy || '默认值'; // 这种判断方式，只针对 ayy = null 或 ayy = undefined 或 ayy = ''空字符串 这3中情况
            console.log('byy = ', byy)
        }


    </script>

    <script>
        function jiajialianxi() {
            'use strict';

            let n = 1;
            let m = 2;
            let f = m + ++n; // 这个表达式，会先让 ++n 即 n 会先 加 1，后再加上 m 的值
            // 上面的 let f = m + ++n; 等同于 let f = m + (n = n + 1); ，即可以简写为 let f = m + ++n;
            // let f = m + (n = n + 1);
            console.log('n =', n);
            n = 1;
            let g = m + n++; // 这个表达式，会先把 m 和 n 相加得到值后，再对 n 进行加 1，所以这里的 g 等同于 g = m + n
            console.log('n =', n);

            console.log('f =', f);
            console.log('g =', f);
            console.log('n =', n);



        }
    </script>
    <script>
        function mobanlianxi() {
            // 【标签模板 练习】

            const INFO = [
                {
                    author: '李寻欢',
                    title: "bilibili的学习资料"
                },
                {
                    author: '风云雄霸',
                    title: "没有广告的bilibili"
                },
                {
                    author: '小李子',
                    title: "我喜欢在bilibili的上看学习视频"
                }
            ];

            const template = () => {
                return `<ul>
            ${INFO.map(item =>
                    link`<li>用户：${item.author}；内容：${item.title}</li>`
                ).join('')}
            </ul>`
            }

            const link = (strings, ...vars) => {
                console.log('strings => ', strings);
                console.log('vars => ', vars);

                return strings.map((str, key) => {
                    console.log('str', str)
                    console.log('key', key)

                    return str + (!vars[key] ? ''
                        : vars[key].replace('bilibili',
                            `<a href='https://www.bilibili.com/' target='_blank'> bilibili </a>`));
                });
            }

            document.body.innerHTML = template()
        }

        // mobanlianxi()

    </script>

    <script>
        function mohuchulianxi() {
            // 【电话号码模糊处理】

            // 'abcdefg'.slice(a,b) 从字符串中截取指定字符，a 是开始索引(从0开始)，如果 b 为正数，那么从左开始截取，如果 b 为负数，那么从右边开始截取
            // '*'.repeat(n) 会复制 n 遍同样的字符
            const phone = (moblie, len = 3) => String(moblie).slice(0, len * -1) + '*'.repeat(len)

            const phoneOld = 13058748345
            let html = `<span>原来的号码：${phoneOld}</span><br />`;
            html += `<span>经过模糊处理后的号码：${phone(13058748345, 4)}</span>`
            document.body.innerHTML += html
        }
    </script>

    <script>
        {
            // 【年份回答的boolean练习】

            // while (true) {
            //     const year = prompt("哪年出生的？").trim();
            //     if (!year) continue;
            //     console.log(year === '1992' ? '回答正确' : '回答错误');
            //     break;
            // }
        }
    </script>


    <script>
        function suijilianxi() {
            // 【Math 随机数练习】

            // Math.random() 随机数生成范围：0 ~ 1 之间的浮点数，包括0，但小于1
            console.log('随机数：', Math.random());

            // 这种方案不可行
            // console.log('随机数(利用向上取整，获取 0 ~ 5[包括0和5] 之间的随机数)：',
            // Math.ceil(Math.random() * 5));
            // 只能用这种方案
            console.log('随机数(利用向下取整，获取 0 ~ 5[包括0和5] 之间的随机数)：',
                Math.floor(Math.random() * (5 + 1)));

            // 这种方案不可行
            // console.log('随机数(利用向上取整，获取 2 ~ 5[包括0和5] 之间的随机数)：',
            // Math.ceil(2+Math.random() * 5-2));
            // 只能用这种方案
            console.log('随机数(利用向下取整，获取 2 ~ 5[包括0和5] 之间的随机数)：',
                Math.floor(2 + Math.random() * (5 - 2 + 1)));

            // 从字符串中随机去
            const names = 'abcdefg';
            let nameIndex = Math.floor(Math.random() * names.length);
            console.log('字符串长度:', names.length);
            console.log('字符串最大索引:', names.length - 1);
            console.log('字符随机索引:', nameIndex);
            console.log('从字符串【abcdefg】随机取一个字符', names[nameIndex]);
        }
    </script>

    <script>
        function shijianlianxi() {

            // ISO（标准时间）日期 转 时间戳
            // debugger
            const dateA = new Date('1992-7-12 12:12:12');
            console.log('1992-7-12 12:12:12 的时间戳', dateA * 1);
            console.log('1992-7-12 12:12:12 的时间戳', Number(dateA));
            console.log('1992-7-12 12:12:12 的时间戳', dateA.getTime());
            console.log('1992-7-12 12:12:12 的时间戳', dateA.valueOf());

            const timespan = dateA.valueOf();
            console.log('ISO日期:', new Date(timespan));

            // 封装日期格式化函数
            const dateFormat = (date, format = 'YYYY-MM-DD HH:mm:ss') => {
                if (!(date instanceof Date)) return '这不是日期类型'
                console.log('要转换的日期：', date)

                // console.log('年：',date.getFullYear())
                // console.log('月：',date.getMonth()+1) // js 中的ISO日期类型的月份转为数字是从0开始计算的，也就是说1月份转为数字是0，所以要加1
                // console.log('日：',date.getDate())
                // console.log('时：',date.getHours())
                // console.log('分：',date.getMinutes())
                // console.log('秒：',date.getSeconds())

                const CONFIG = {
                    YYYY: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    DD: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                }

                // console.log(Object.keys(CONFIG)) // 获取 JSON 对象中所有的key，并以数组形式输出
                Object.keys(CONFIG).map(item => format = format.replace(item, CONFIG[item]));
                // const r = Object.keys(CONFIG).map(item=>format = format.replace(item,CONFIG[item]));
                // console.log('r : ',r)

                return format
            }


            console.log('经过格式化后的日期字符串：', dateFormat(new Date('2020/1/1 12:10:9'), 'YYYY年MM月DD日 HH时mm分ss秒'))
        }
    </script>

    <script>
        function shuzulianxi() {
            const hd = [1, 2, 3, 5, 6, 9, 8];
            console.log(hd);
            console.table(hd);

            // 这种方式创建数组，后面的6的意义时，创建一个有6个成员的数组，每个成员都是undefined
            const arrA = new Array(6);
            console.log('arrA 数组的长度: ', arrA.length);
            console.log('arrA 数组的内容: ', arrA)
            console.log('arrA 数组的所有成员: ');
            for (let item of arrA) console.log(item);
            console.table(arrA); // 如果所有数组都是undefined，console.table() 是不会输出任何内容的

            // 用 Array.of(xxx,xxx,xxx) 等同于 arr = [xxx,xxx,xxx] 可以初始化一个带相应成员的数组
            const arrB = Array.of(6, undefined, 7);
            console.log('arrB 数组的长度: ', arrB.length);
            console.log('arrB 数组的内容: ', arrB);
            console.table(arrB);

            // 计算数组中成员的累加和，利用 array.reduce(function,defaultValue)
            // reduce() 函数的资料参考： https://www.runoob.com/jsref/jsref-reduce.html
            const arrC = [9, 5, 7, 2, 7.2];
            const sum = arrC.reduce((total, curVal, curIndex, arr) => {
                // console.log('curIndex',curIndex);
                // console.log('arr',arr);

                // Math.round() 是对数值进行四舍五入取整
                // return total + Math.round(curVal);
                // 不取整求和
                return total + curVal;
            }, 0);
            console.log(`数组${arrC.toString()}的求和结果：${sum}`);


            // 数组移动
            // 把 arr 数组中的索引为 indexFrom 的成员移动到 索引为 indexTo 的位置
            const moveArray = (arr, indexFrom, indexTo) => {
                if (!Array.isArray(arr)) {
                    console.error('arr 参数不是数组');
                    return '';
                }
                if (indexFrom < 0 || indexTo > arr.length - 1) {
                    console.error('indexFrom 或 indexTo 索引参数超出数组范围');
                    return '';
                }
                const fromVal = arr.splice(indexFrom, 1)[0];
                arr.splice(indexTo, 0, fromVal);
                return arr;
            }
            const arrD = [1, 2, 3, 4, 5];

            // moveArray(arrD,1,3);
            console.log('移动后的数组：');
            console.table(moveArray(arrD, 1, 3));

            arrD.sort((a, b) => {
                return b - a
            });

            console.table(arrD);

        }
    </script>

    <script>
        function thislianxi() {
            // 【call apply bind 练习】
            // 通过 call apply bind 可以改变 this
            // 区别： call apply 会立即执行，bind 不会立即执行，还需要进行调用后才会执行
            // call apply 的区别：function.call({...},a,b,c,...); function.apply({...},[a,b,c,...]); call 和 apply 唯一的区别就是后面传参不通，一个是逗号隔开的多个参数，一个是数组参数

            // 1、call 案例
            function Boos(a, b) {
                console.log('Boos this => ', this);
                console.log('Boos a,b =>', a, b);
            }
            Boos.call({ label: 'boos' }, 1, 2);

            // 2、apply 案例
            function Employ(a, b) {
                console.log('Employ this => ', this);
                console.log('Employ a,b =>', a, b);
            }
            Employ.apply({ label: 'employ' }, [2, 3]);

            // 3、apply 的巧妙案例
            // （案例：取最大值）
            const arr = [1, 4, 17, 3, 7, 7, 9];
            console.log('arr => ', arr);
            // Math.max(a,b,c,d) 这个获取最大值的函数的参数必须是逗号隔开的参数
            // 我们可以通过三个点的展开表达式把数组展开进行使用
            console.log('最大值 : ', Math.max(...arr));
            // 然后我们可以巧妙使用 apply 来把数组展开
            console.log('利用call展开数组，得到最大值 = ', Math.max.apply(Math, arr));

            // 4、call apply 实现函数(js的类其实也就是函数的包装，所以类也可以)的继承 案例
            function Base(paramA, paramB) {
                this.getInfo = function (funcParams) {
                    console.log('基类的函数的this：', this);
                    console.log('来自子类的参数：', paramA, paramB);
                    console.log('基类的函数接收的参数：', funcParams);
                }
            }
            function ChildA(tag, age) {
                this.tag = tag;
                this.age = age;

                Base.call(this, tag, age);
            }
            function ChildB(label, sex) {
                this.label = label;
                this.sex = sex;
                Base.apply(this, [label, sex]);
            }
            const cA = new ChildA('ChildA', 18);
            cA.getInfo(['childA aaa'])
            const cB = new ChildB('ChildB', '男');
            cB.getInfo(['ChildB bbb']);

            // 5、bind 案例
            function Demo(a, b) {
                console.log('bind 案例：', a, b);
            }
            Demo.bind({ demo: 'bind demo' }, 2, 3); // bind不会立即执行
            Demo.bind({ demo: 'bind demo' }, 2, 3)(); // bind需要被调用才会执行
            // 我们可以先用bind，返回一个函数，然后调用这个函数
            const demoFunc = Demo.bind({ demo: 'bind demo' });
            demoFunc(1, 2);
            // 注意：bind时候也可以传参数，但是如果绑定时的传参，会直接覆盖调用的传参
            // (1) 不完整传参的效果，文字不太好描述，具体看下面的效果
            const demoFuncA = Demo.bind({ demo: 'bind demo' }, 5);
            // 这里你会发现只打印了 5 和 7,参数9没有了，
            // 因为bind的时候附加了一个5，那么调用的时候，
            // 就只会补全bind时没有传递的参数，而调用时多余的参数就会被丢弃
            demoFuncA(7, 9);
            // (1) 完整传参的效果，按照上面的说法，这里调用处就算传参了也没用，
            // 因为只会优先使用bind时传递的参数，要想调用时候传参，
            // 那就bind的时候任何参数都不要传递
            const demoFuncB = Demo.bind({ demo: 'bind demo' }, 10, 6);
            demoFuncB(7, 9);



        }
    </script>

    <script>
        {
            const protecteds = Symbol();
            class Base {
                constructor() {
                    this[protecteds] = {}
                }
            }
            class User extends Base {
                constructor(name) {
                    super();
                    this[protecteds].name = name;
                    this[protecteds].url = 'https';
                }

                set url(val) {
                    if (!/^https?:/i.test(val)) {
                        throw new Error('非https网址');
                    }
                    this[protecteds].url = val;
                }

                get url() {
                    console.log('ccc')
                    return this[protecteds].url;
                }
            }

            Object.seal(User);


            // const u = new User('mic');
            // console.log(JSON.stringify(Object.getOwnPropertyDescriptor(u, protecteds), null, 2))
            // Object.defineProperty(u, protecteds, {
            //     writable: false, // 是否可写 对象属性是否可修改,flase为不可修改，默认值为true
            //     enumerable: false, // 对象属性是否可通过遍历(循环)，flase为不可循环，默认值为true
            //     configurable: false // 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true
            // })
            // console.log(JSON.stringify(Object.getOwnPropertyDescriptor(u, protecteds), null, 2))
            // u[protecteds].url = 'aaa';
            // u[protecteds].boy = 'bbb';
            // console.log('user = ', u.url);
            // console.log('user = ', u[protecteds].boy);


        }
    </script>
</body>

</html>